/* automatically generated by rust-bindgen 0.72.0 */

pub const NULL: u32 = 0;
pub const _VCRT_COMPILER_PREPROCESSOR: u32 = 1;
pub const _SAL_VERSION: u32 = 20;
pub const __SAL_H_VERSION: u32 = 180000000;
pub const _USE_DECLSPECS_FOR_SAL: u32 = 0;
pub const _USE_ATTRIBUTES_FOR_SAL: u32 = 0;
pub const _CRT_PACKING: u32 = 8;
pub const _HAS_EXCEPTIONS: u32 = 1;
pub const _HAS_CXX17: u32 = 0;
pub const _HAS_CXX20: u32 = 0;
pub const _HAS_CXX23: u32 = 0;
pub const _HAS_CXX26: u32 = 0;
pub const _HAS_NODISCARD: u32 = 1;
pub const WCHAR_MIN: u32 = 0;
pub const WCHAR_MAX: u32 = 65535;
pub const WINT_MIN: u32 = 0;
pub const WINT_MAX: u32 = 65535;
pub const __bool_true_false_are_defined: u32 = 1;
pub type std_nullptr_t = *const ::std::os::raw::c_void;
pub type max_align_t = f64;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct saucer_options {
    _unused: [u8; 0]
}
unsafe extern "C" {
    pub fn saucer_options_new(id: *const ::std::os::raw::c_char) -> *mut saucer_options;
}
unsafe extern "C" {
    pub fn saucer_options_free(arg1: *mut saucer_options);
}
unsafe extern "C" {
    pub fn saucer_options_set_argc(arg1: *mut saucer_options, argc: ::std::os::raw::c_int);
}
unsafe extern "C" {
    pub fn saucer_options_set_argv(arg1: *mut saucer_options, argv: *mut *mut ::std::os::raw::c_char);
}
unsafe extern "C" {
    pub fn saucer_options_set_threads(arg1: *mut saucer_options, threads: usize);
}
#[doc = " @brief A handle to a saucer::application\n @note The application will live as long as there are handles to it. So make sure to properly free all handles you\n obtain to a saucer::application like through e.g. `saucer_application_active`!"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct saucer_application {
    _unused: [u8; 0]
}
unsafe extern "C" {
    pub fn saucer_application_init(options: *mut saucer_options) -> *mut saucer_application;
}
unsafe extern "C" {
    pub fn saucer_application_free(arg1: *mut saucer_application);
}
unsafe extern "C" {
    pub fn saucer_application_active() -> *mut saucer_application;
}
unsafe extern "C" {
    pub fn saucer_application_thread_safe(arg1: *mut saucer_application) -> bool;
}
pub type saucer_pool_callback = ::std::option::Option<unsafe extern "C" fn()>;
unsafe extern "C" {
    #[doc = " @brief Submits (blocking) the given @param callback to the thread-pool"]
    pub fn saucer_application_pool_submit(arg1: *mut saucer_application, callback: saucer_pool_callback);
}
unsafe extern "C" {
    #[doc = " @brief Emplaces (non blocking) the given @param callback to the thread-pool"]
    pub fn saucer_application_pool_emplace(arg1: *mut saucer_application, callback: saucer_pool_callback);
}
pub type saucer_post_callback = ::std::option::Option<unsafe extern "C" fn()>;
unsafe extern "C" {
    pub fn saucer_application_post(arg1: *mut saucer_application, callback: saucer_post_callback);
}
pub type saucer_pool_callback_with_arg = ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>;
unsafe extern "C" {
    pub fn saucer_application_pool_submit_with_arg(
        arg1: *mut saucer_application,
        callback: saucer_pool_callback_with_arg,
        arg: *mut ::std::os::raw::c_void
    );
}
unsafe extern "C" {
    pub fn saucer_application_pool_emplace_with_arg(
        arg1: *mut saucer_application,
        callback: saucer_pool_callback_with_arg,
        arg: *mut ::std::os::raw::c_void
    );
}
pub type saucer_post_callback_with_arg = ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>;
unsafe extern "C" {
    #[doc = " @brief Similar to `saucer_application_post`, but allows to pass an argument.\n This is needed for Rust closures to be passed and executed safely."]
    pub fn saucer_application_post_with_arg(
        arg1: *mut saucer_application,
        callback: saucer_post_callback_with_arg,
        arg: *mut ::std::os::raw::c_void
    );
}
unsafe extern "C" {
    pub fn saucer_application_quit(arg1: *mut saucer_application);
}
unsafe extern "C" {
    pub fn saucer_application_run(arg1: *mut saucer_application);
}
unsafe extern "C" {
    pub fn saucer_application_run_once(arg1: *mut saucer_application);
}
pub type va_list = *mut ::std::os::raw::c_char;
unsafe extern "C" {
    pub fn __va_start(arg1: *mut va_list, ...);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __vcrt_va_list_is_reference {
    pub _address: u8
}
pub const __vcrt_va_list_is_reference___the_value: __vcrt_va_list_is_reference__bindgen_ty_1 = false;
pub type __vcrt_va_list_is_reference__bindgen_ty_1 = bool;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __vcrt_assert_va_start_is_not_reference {
    pub _address: u8
}
pub type __vcrt_bool = bool;
unsafe extern "C" {
    pub fn __security_init_cookie();
}
unsafe extern "C" {
    pub fn __security_check_cookie(_StackCookie: usize);
}
unsafe extern "C" {
    pub fn __report_gsfailure(_StackCookie: usize) -> !;
}
unsafe extern "C" {
    pub static mut __security_cookie: usize;
}
pub type int_least8_t = ::std::os::raw::c_schar;
pub type int_least16_t = ::std::os::raw::c_short;
pub type int_least32_t = ::std::os::raw::c_int;
pub type int_least64_t = ::std::os::raw::c_longlong;
pub type uint_least8_t = ::std::os::raw::c_uchar;
pub type uint_least16_t = ::std::os::raw::c_ushort;
pub type uint_least32_t = ::std::os::raw::c_uint;
pub type uint_least64_t = ::std::os::raw::c_ulonglong;
pub type int_fast8_t = ::std::os::raw::c_schar;
pub type int_fast16_t = ::std::os::raw::c_int;
pub type int_fast32_t = ::std::os::raw::c_int;
pub type int_fast64_t = ::std::os::raw::c_longlong;
pub type uint_fast8_t = ::std::os::raw::c_uchar;
pub type uint_fast16_t = ::std::os::raw::c_uint;
pub type uint_fast32_t = ::std::os::raw::c_uint;
pub type uint_fast64_t = ::std::os::raw::c_ulonglong;
pub type intmax_t = ::std::os::raw::c_longlong;
pub type uintmax_t = ::std::os::raw::c_ulonglong;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct saucer_stash {
    _unused: [u8; 0]
}
unsafe extern "C" {
    pub fn saucer_stash_free(arg1: *mut saucer_stash);
}
unsafe extern "C" {
    pub fn saucer_stash_size(arg1: *mut saucer_stash) -> usize;
}
unsafe extern "C" {
    pub fn saucer_stash_data(arg1: *mut saucer_stash) -> *const u8;
}
unsafe extern "C" {
    pub fn saucer_stash_from(data: *const u8, size: usize) -> *mut saucer_stash;
}
unsafe extern "C" {
    pub fn saucer_stash_view(data: *const u8, size: usize) -> *mut saucer_stash;
}
pub type saucer_stash_lazy_callback = ::std::option::Option<unsafe extern "C" fn() -> *mut saucer_stash>;
pub type saucer_stash_lazy_callback_with_arg =
    ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void) -> *mut saucer_stash>;
unsafe extern "C" {
    #[doc = " @note The stash returned from within the @param callback is automatically deleted. However, the stash returned\n from this function must still be free'd accordingly."]
    pub fn saucer_stash_lazy(callback: saucer_stash_lazy_callback) -> *mut saucer_stash;
}
unsafe extern "C" {
    pub fn saucer_stash_lazy_with_arg(
        callback: saucer_stash_lazy_callback_with_arg,
        arg: *mut ::std::os::raw::c_void
    ) -> *mut saucer_stash;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct saucer_icon {
    _unused: [u8; 0]
}
unsafe extern "C" {
    pub fn saucer_icon_free(arg1: *mut saucer_icon);
}
unsafe extern "C" {
    pub fn saucer_icon_empty(arg1: *mut saucer_icon) -> bool;
}
unsafe extern "C" {
    pub fn saucer_icon_data(arg1: *mut saucer_icon) -> *mut saucer_stash;
}
unsafe extern "C" {
    pub fn saucer_icon_save(arg1: *mut saucer_icon, path: *const ::std::os::raw::c_char);
}
unsafe extern "C" {
    #[doc = " @brief Try to construct an icon from a given file.\n @note The pointer pointed to by @param result will be set to a saucer_icon in case of success. The returned icon\n must be free'd."]
    pub fn saucer_icon_from_file(result: *mut *mut saucer_icon, file: *const ::std::os::raw::c_char);
}
unsafe extern "C" {
    #[doc = " @brief Try to construct an icon from a given stash (raw bytes).\n @note The pointer pointed to by @param result will be set to a saucer_icon in case of success. The returned icon\n must be free'd."]
    pub fn saucer_icon_from_data(result: *mut *mut saucer_icon, stash: *mut saucer_stash);
}
unsafe extern "C" {
    pub fn saucer_memory_free(data: *mut ::std::os::raw::c_void);
}
unsafe extern "C" {
    pub fn saucer_memory_alloc(size: usize) -> *mut ::std::os::raw::c_void;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct saucer_navigation {
    _unused: [u8; 0]
}
unsafe extern "C" {
    pub fn saucer_navigation_free(arg1: *mut saucer_navigation);
}
unsafe extern "C" {
    pub fn saucer_navigation_url(arg1: *mut saucer_navigation) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn saucer_navigation_new_window(arg1: *mut saucer_navigation) -> bool;
}
unsafe extern "C" {
    pub fn saucer_navigation_redirection(arg1: *mut saucer_navigation) -> bool;
}
unsafe extern "C" {
    pub fn saucer_navigation_user_initiated(arg1: *mut saucer_navigation) -> bool;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct saucer_preferences {
    _unused: [u8; 0]
}
unsafe extern "C" {
    pub fn saucer_preferences_new(app: *mut saucer_application) -> *mut saucer_preferences;
}
unsafe extern "C" {
    pub fn saucer_preferences_free(arg1: *mut saucer_preferences);
}
unsafe extern "C" {
    pub fn saucer_preferences_set_persistent_cookies(arg1: *mut saucer_preferences, enabled: bool);
}
unsafe extern "C" {
    pub fn saucer_preferences_set_hardware_acceleration(arg1: *mut saucer_preferences, enabled: bool);
}
unsafe extern "C" {
    pub fn saucer_preferences_set_storage_path(arg1: *mut saucer_preferences, path: *const ::std::os::raw::c_char);
}
unsafe extern "C" {
    pub fn saucer_preferences_add_browser_flag(arg1: *mut saucer_preferences, flag: *const ::std::os::raw::c_char);
}
unsafe extern "C" {
    pub fn saucer_preferences_set_user_agent(arg1: *mut saucer_preferences, user_agent: *const ::std::os::raw::c_char);
}
pub const SAUCER_WINDOW_EVENT_SAUCER_WINDOW_EVENT_DECORATED: SAUCER_WINDOW_EVENT = 0;
pub const SAUCER_WINDOW_EVENT_SAUCER_WINDOW_EVENT_MAXIMIZE: SAUCER_WINDOW_EVENT = 1;
pub const SAUCER_WINDOW_EVENT_SAUCER_WINDOW_EVENT_MINIMIZE: SAUCER_WINDOW_EVENT = 2;
pub const SAUCER_WINDOW_EVENT_SAUCER_WINDOW_EVENT_CLOSED: SAUCER_WINDOW_EVENT = 3;
pub const SAUCER_WINDOW_EVENT_SAUCER_WINDOW_EVENT_RESIZE: SAUCER_WINDOW_EVENT = 4;
pub const SAUCER_WINDOW_EVENT_SAUCER_WINDOW_EVENT_FOCUS: SAUCER_WINDOW_EVENT = 5;
pub const SAUCER_WINDOW_EVENT_SAUCER_WINDOW_EVENT_CLOSE: SAUCER_WINDOW_EVENT = 6;
pub type SAUCER_WINDOW_EVENT = ::std::os::raw::c_int;
pub const SAUCER_WINDOW_EDGE_SAUCER_WINDOW_EDGE_TOP: SAUCER_WINDOW_EDGE = 1;
pub const SAUCER_WINDOW_EDGE_SAUCER_WINDOW_EDGE_BOTTOM: SAUCER_WINDOW_EDGE = 2;
pub const SAUCER_WINDOW_EDGE_SAUCER_WINDOW_EDGE_LEFT: SAUCER_WINDOW_EDGE = 4;
pub const SAUCER_WINDOW_EDGE_SAUCER_WINDOW_EDGE_RIGHT: SAUCER_WINDOW_EDGE = 8;
pub type SAUCER_WINDOW_EDGE = ::std::os::raw::c_int;
pub const SAUCER_POLICY_SAUCER_POLICY_ALLOW: SAUCER_POLICY = 0;
pub const SAUCER_POLICY_SAUCER_POLICY_BLOCK: SAUCER_POLICY = 1;
pub type SAUCER_POLICY = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct saucer_handle {
    _unused: [u8; 0]
}
unsafe extern "C" {
    pub fn saucer_window_visible(arg1: *mut saucer_handle) -> bool;
}
unsafe extern "C" {
    pub fn saucer_window_focused(arg1: *mut saucer_handle) -> bool;
}
unsafe extern "C" {
    pub fn saucer_window_minimized(arg1: *mut saucer_handle) -> bool;
}
unsafe extern "C" {
    pub fn saucer_window_maximized(arg1: *mut saucer_handle) -> bool;
}
unsafe extern "C" {
    pub fn saucer_window_resizable(arg1: *mut saucer_handle) -> bool;
}
unsafe extern "C" {
    pub fn saucer_window_decorations(arg1: *mut saucer_handle) -> bool;
}
unsafe extern "C" {
    pub fn saucer_window_always_on_top(arg1: *mut saucer_handle) -> bool;
}
unsafe extern "C" {
    pub fn saucer_window_click_through(arg1: *mut saucer_handle) -> bool;
}
unsafe extern "C" {
    pub fn saucer_window_title(arg1: *mut saucer_handle) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn saucer_window_size(
        arg1: *mut saucer_handle,
        width: *mut ::std::os::raw::c_int,
        height: *mut ::std::os::raw::c_int
    );
}
unsafe extern "C" {
    pub fn saucer_window_max_size(
        arg1: *mut saucer_handle,
        width: *mut ::std::os::raw::c_int,
        height: *mut ::std::os::raw::c_int
    );
}
unsafe extern "C" {
    pub fn saucer_window_min_size(
        arg1: *mut saucer_handle,
        width: *mut ::std::os::raw::c_int,
        height: *mut ::std::os::raw::c_int
    );
}
unsafe extern "C" {
    pub fn saucer_window_hide(arg1: *mut saucer_handle);
}
unsafe extern "C" {
    pub fn saucer_window_show(arg1: *mut saucer_handle);
}
unsafe extern "C" {
    pub fn saucer_window_close(arg1: *mut saucer_handle);
}
unsafe extern "C" {
    pub fn saucer_window_focus(arg1: *mut saucer_handle);
}
unsafe extern "C" {
    pub fn saucer_window_start_drag(arg1: *mut saucer_handle);
}
unsafe extern "C" {
    pub fn saucer_window_start_resize(arg1: *mut saucer_handle, edge: SAUCER_WINDOW_EDGE);
}
unsafe extern "C" {
    pub fn saucer_window_set_minimized(arg1: *mut saucer_handle, enabled: bool);
}
unsafe extern "C" {
    pub fn saucer_window_set_maximized(arg1: *mut saucer_handle, enabled: bool);
}
unsafe extern "C" {
    pub fn saucer_window_set_resizable(arg1: *mut saucer_handle, enabled: bool);
}
unsafe extern "C" {
    pub fn saucer_window_set_decorations(arg1: *mut saucer_handle, enabled: bool);
}
unsafe extern "C" {
    pub fn saucer_window_set_always_on_top(arg1: *mut saucer_handle, enabled: bool);
}
unsafe extern "C" {
    pub fn saucer_window_set_click_through(arg1: *mut saucer_handle, enabled: bool);
}
unsafe extern "C" {
    pub fn saucer_window_set_icon(arg1: *mut saucer_handle, icon: *mut saucer_icon);
}
unsafe extern "C" {
    pub fn saucer_window_set_title(arg1: *mut saucer_handle, title: *const ::std::os::raw::c_char);
}
unsafe extern "C" {
    pub fn saucer_window_set_size(
        arg1: *mut saucer_handle,
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int
    );
}
unsafe extern "C" {
    pub fn saucer_window_set_max_size(
        arg1: *mut saucer_handle,
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int
    );
}
unsafe extern "C" {
    pub fn saucer_window_set_min_size(
        arg1: *mut saucer_handle,
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int
    );
}
unsafe extern "C" {
    pub fn saucer_window_clear(arg1: *mut saucer_handle, event: SAUCER_WINDOW_EVENT);
}
unsafe extern "C" {
    pub fn saucer_window_remove(arg1: *mut saucer_handle, event: SAUCER_WINDOW_EVENT, id: u64);
}
unsafe extern "C" {
    #[doc = " @note See respective comment on events in \"window.h\"\n @warning The icon passed to the @param callback in the `web_event::icon_changed` event must be free'd by the\n user"]
    pub fn saucer_window_once(
        arg1: *mut saucer_handle,
        event: SAUCER_WINDOW_EVENT,
        callback: *mut ::std::os::raw::c_void
    );
}
unsafe extern "C" {
    pub fn saucer_window_once_with_arg(
        arg1: *mut saucer_handle,
        event: SAUCER_WINDOW_EVENT,
        callback: *mut ::std::os::raw::c_void,
        arg: *mut ::std::os::raw::c_void
    );
}
unsafe extern "C" {
    pub fn saucer_window_on(
        arg1: *mut saucer_handle,
        event: SAUCER_WINDOW_EVENT,
        callback: *mut ::std::os::raw::c_void
    ) -> u64;
}
unsafe extern "C" {
    pub fn saucer_window_on_with_arg(
        arg1: *mut saucer_handle,
        event: SAUCER_WINDOW_EVENT,
        callback: *mut ::std::os::raw::c_void,
        arg: *mut ::std::os::raw::c_void
    ) -> u64;
}
pub const SAUCER_SCHEME_ERROR_SAUCER_REQUEST_ERROR_NOT_FOUND: SAUCER_SCHEME_ERROR = 0;
pub const SAUCER_SCHEME_ERROR_SAUCER_REQUEST_ERROR_INVALID: SAUCER_SCHEME_ERROR = 1;
pub const SAUCER_SCHEME_ERROR_SAUCER_REQUEST_ERROR_ABORTED: SAUCER_SCHEME_ERROR = 2;
pub const SAUCER_SCHEME_ERROR_SAUCER_REQUEST_ERROR_DENIED: SAUCER_SCHEME_ERROR = 3;
pub const SAUCER_SCHEME_ERROR_SAUCER_REQUEST_ERROR_FAILED: SAUCER_SCHEME_ERROR = 4;
pub type SAUCER_SCHEME_ERROR = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct saucer_scheme_response {
    _unused: [u8; 0]
}
unsafe extern "C" {
    pub fn saucer_scheme_response_new(
        data: *mut saucer_stash,
        mime: *const ::std::os::raw::c_char
    ) -> *mut saucer_scheme_response;
}
unsafe extern "C" {
    pub fn saucer_scheme_response_free(arg1: *mut saucer_scheme_response);
}
unsafe extern "C" {
    pub fn saucer_scheme_response_set_status(arg1: *mut saucer_scheme_response, status: ::std::os::raw::c_int);
}
unsafe extern "C" {
    pub fn saucer_scheme_response_add_header(
        arg1: *mut saucer_scheme_response,
        header: *const ::std::os::raw::c_char,
        value: *const ::std::os::raw::c_char
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct saucer_scheme_request {
    _unused: [u8; 0]
}
unsafe extern "C" {
    pub fn saucer_scheme_request_free(arg1: *mut saucer_scheme_request);
}
unsafe extern "C" {
    pub fn saucer_scheme_request_url(arg1: *mut saucer_scheme_request) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn saucer_scheme_request_method(arg1: *mut saucer_scheme_request) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn saucer_scheme_request_content(arg1: *mut saucer_scheme_request) -> *mut saucer_stash;
}
unsafe extern "C" {
    #[doc = " @note The arrays pointed to by @param headers and @param values will be populated with strings which are\n themselves dynamically allocated. Both arrays will then hold @param count elements.\n\n To properly free the returned arrays you should:\n - Free all strings within the headers and values array\n - Free the array itself"]
    pub fn saucer_scheme_request_headers(
        arg1: *mut saucer_scheme_request,
        headers: *mut *mut *mut ::std::os::raw::c_char,
        values: *mut *mut *mut ::std::os::raw::c_char,
        count: *mut usize
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct saucer_scheme_executor {
    _unused: [u8; 0]
}
unsafe extern "C" {
    pub fn saucer_scheme_executor_free(arg1: *mut saucer_scheme_executor);
}
unsafe extern "C" {
    pub fn saucer_scheme_executor_resolve(arg1: *mut saucer_scheme_executor, response: *mut saucer_scheme_response);
}
unsafe extern "C" {
    pub fn saucer_scheme_executor_reject(arg1: *mut saucer_scheme_executor, error: SAUCER_SCHEME_ERROR);
}
pub type saucer_scheme_handler = ::std::option::Option<
    unsafe extern "C" fn(arg1: *mut saucer_handle, arg2: *mut saucer_scheme_request, arg3: *mut saucer_scheme_executor)
>;
pub type saucer_scheme_handler_with_arg = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *mut saucer_handle,
        arg2: *mut saucer_scheme_request,
        arg3: *mut saucer_scheme_executor,
        arg: *mut ::std::os::raw::c_void
    )
>;
pub const SAUCER_LOAD_TIME_SAUCER_LOAD_TIME_CREATION: SAUCER_LOAD_TIME = 0;
pub const SAUCER_LOAD_TIME_SAUCER_LOAD_TIME_READY: SAUCER_LOAD_TIME = 1;
pub type SAUCER_LOAD_TIME = ::std::os::raw::c_int;
pub const SAUCER_WEB_FRAME_SAUCER_WEB_FRAME_TOP: SAUCER_WEB_FRAME = 0;
pub const SAUCER_WEB_FRAME_SAUCER_WEB_FRAME_ALL: SAUCER_WEB_FRAME = 1;
pub type SAUCER_WEB_FRAME = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct saucer_script {
    _unused: [u8; 0]
}
unsafe extern "C" {
    pub fn saucer_script_new(code: *const ::std::os::raw::c_char, time: SAUCER_LOAD_TIME) -> *mut saucer_script;
}
unsafe extern "C" {
    pub fn saucer_script_free(arg1: *mut saucer_script);
}
unsafe extern "C" {
    pub fn saucer_script_set_frame(arg1: *mut saucer_script, frame: SAUCER_WEB_FRAME);
}
unsafe extern "C" {
    pub fn saucer_script_set_time(arg1: *mut saucer_script, time: SAUCER_LOAD_TIME);
}
unsafe extern "C" {
    pub fn saucer_script_set_permanent(arg1: *mut saucer_script, permanent: bool);
}
unsafe extern "C" {
    pub fn saucer_script_set_code(arg1: *mut saucer_script, code: *const ::std::os::raw::c_char);
}
pub const SAUCER_WEB_EVENT_SAUCER_WEB_EVENT_DOM_READY: SAUCER_WEB_EVENT = 0;
pub const SAUCER_WEB_EVENT_SAUCER_WEB_EVENT_NAVIGATED: SAUCER_WEB_EVENT = 1;
pub const SAUCER_WEB_EVENT_SAUCER_WEB_EVENT_NAVIGATE: SAUCER_WEB_EVENT = 2;
pub const SAUCER_WEB_EVENT_SAUCER_WEB_EVENT_FAVICON: SAUCER_WEB_EVENT = 3;
pub const SAUCER_WEB_EVENT_SAUCER_WEB_EVENT_TITLE: SAUCER_WEB_EVENT = 4;
pub const SAUCER_WEB_EVENT_SAUCER_WEB_EVENT_LOAD: SAUCER_WEB_EVENT = 5;
pub type SAUCER_WEB_EVENT = ::std::os::raw::c_int;
pub const SAUCER_STATE_SAUCER_STATE_STARTED: SAUCER_STATE = 0;
pub const SAUCER_STATE_SAUCER_STATE_FINISHED: SAUCER_STATE = 1;
pub type SAUCER_STATE = ::std::os::raw::c_int;
pub const SAUCER_LAUNCH_SAUCER_LAUNCH_SYNC: SAUCER_LAUNCH = 0;
pub const SAUCER_LAUNCH_SAUCER_LAUNCH_ASYNC: SAUCER_LAUNCH = 1;
pub type SAUCER_LAUNCH = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct saucer_embedded_file {
    _unused: [u8; 0]
}
unsafe extern "C" {
    pub fn saucer_embed(content: *mut saucer_stash, mime: *const ::std::os::raw::c_char) -> *mut saucer_embedded_file;
}
unsafe extern "C" {
    pub fn saucer_embed_free(arg1: *mut saucer_embedded_file);
}
unsafe extern "C" {
    pub fn saucer_new(prefs: *mut saucer_preferences) -> *mut saucer_handle;
}
unsafe extern "C" {
    pub fn saucer_free(arg1: *mut saucer_handle);
}
pub type saucer_on_message = ::std::option::Option<unsafe extern "C" fn(arg1: *const ::std::os::raw::c_char) -> bool>;
unsafe extern "C" {
    pub fn saucer_webview_on_message(arg1: *mut saucer_handle, callback: saucer_on_message);
}
pub type saucer_on_message_with_arg = ::std::option::Option<
    unsafe extern "C" fn(arg1: *const ::std::os::raw::c_char, arg2: *mut ::std::os::raw::c_void) -> bool
>;
unsafe extern "C" {
    pub fn saucer_webview_on_message_with_arg(
        arg1: *mut saucer_handle,
        callback: saucer_on_message_with_arg,
        arg: *mut ::std::os::raw::c_void
    );
}
unsafe extern "C" {
    pub fn saucer_webview_favicon(arg1: *mut saucer_handle) -> *mut saucer_icon;
}
unsafe extern "C" {
    pub fn saucer_webview_page_title(arg1: *mut saucer_handle) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn saucer_webview_dev_tools(arg1: *mut saucer_handle) -> bool;
}
unsafe extern "C" {
    pub fn saucer_webview_url(arg1: *mut saucer_handle) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn saucer_webview_context_menu(arg1: *mut saucer_handle) -> bool;
}
unsafe extern "C" {
    pub fn saucer_webview_background(arg1: *mut saucer_handle, r: *mut u8, g: *mut u8, b: *mut u8, a: *mut u8);
}
unsafe extern "C" {
    pub fn saucer_webview_force_dark_mode(arg1: *mut saucer_handle) -> bool;
}
unsafe extern "C" {
    pub fn saucer_webview_set_dev_tools(arg1: *mut saucer_handle, enabled: bool);
}
unsafe extern "C" {
    pub fn saucer_webview_set_context_menu(arg1: *mut saucer_handle, enabled: bool);
}
unsafe extern "C" {
    pub fn saucer_webview_set_force_dark_mode(arg1: *mut saucer_handle, enabled: bool);
}
unsafe extern "C" {
    pub fn saucer_webview_set_background(arg1: *mut saucer_handle, r: u8, g: u8, b: u8, a: u8);
}
unsafe extern "C" {
    pub fn saucer_webview_set_file(arg1: *mut saucer_handle, file: *const ::std::os::raw::c_char);
}
unsafe extern "C" {
    pub fn saucer_webview_set_url(arg1: *mut saucer_handle, url: *const ::std::os::raw::c_char);
}
unsafe extern "C" {
    pub fn saucer_webview_back(arg1: *mut saucer_handle);
}
unsafe extern "C" {
    pub fn saucer_webview_forward(arg1: *mut saucer_handle);
}
unsafe extern "C" {
    pub fn saucer_webview_reload(arg1: *mut saucer_handle);
}
unsafe extern "C" {
    pub fn saucer_webview_embed_file(
        arg1: *mut saucer_handle,
        name: *const ::std::os::raw::c_char,
        file: *mut saucer_embedded_file,
        policy: SAUCER_LAUNCH
    );
}
unsafe extern "C" {
    pub fn saucer_webview_serve(arg1: *mut saucer_handle, file: *const ::std::os::raw::c_char);
}
unsafe extern "C" {
    pub fn saucer_webview_clear_scripts(arg1: *mut saucer_handle);
}
unsafe extern "C" {
    pub fn saucer_webview_clear_embedded(arg1: *mut saucer_handle);
}
unsafe extern "C" {
    pub fn saucer_webview_clear_embedded_file(arg1: *mut saucer_handle, file: *const ::std::os::raw::c_char);
}
unsafe extern "C" {
    pub fn saucer_webview_inject(arg1: *mut saucer_handle, script: *mut saucer_script);
}
unsafe extern "C" {
    pub fn saucer_webview_execute(arg1: *mut saucer_handle, code: *const ::std::os::raw::c_char);
}
unsafe extern "C" {
    pub fn saucer_webview_handle_scheme(
        arg1: *mut saucer_handle,
        name: *const ::std::os::raw::c_char,
        handler: saucer_scheme_handler,
        policy: SAUCER_LAUNCH
    );
}
unsafe extern "C" {
    pub fn saucer_webview_handle_scheme_with_arg(
        arg1: *mut saucer_handle,
        name: *const ::std::os::raw::c_char,
        handler: saucer_scheme_handler_with_arg,
        arg: *mut ::std::os::raw::c_void,
        policy: SAUCER_LAUNCH
    );
}
unsafe extern "C" {
    pub fn saucer_webview_remove_scheme(arg1: *mut saucer_handle, name: *const ::std::os::raw::c_char);
}
unsafe extern "C" {
    pub fn saucer_webview_clear(arg1: *mut saucer_handle, event: SAUCER_WEB_EVENT);
}
unsafe extern "C" {
    pub fn saucer_webview_remove(arg1: *mut saucer_handle, event: SAUCER_WEB_EVENT, id: u64);
}
unsafe extern "C" {
    #[doc = " @note The @param callback should be a function pointer to a function matching the event, that is:\n <return-type>(saucer_handle *, <params>...);\n\n Where \"<return-type>\" and \"<params>...\" are to be\n substituted according to the given event signature (see the respective C++ header)\n\n @example web_event::title_changed => void(*)(saucer_handle *, const char *)"]
    pub fn saucer_webview_once(
        arg1: *mut saucer_handle,
        event: SAUCER_WEB_EVENT,
        callback: *mut ::std::os::raw::c_void
    );
}
unsafe extern "C" {
    pub fn saucer_webview_once_with_arg(
        arg1: *mut saucer_handle,
        event: SAUCER_WEB_EVENT,
        callback: *mut ::std::os::raw::c_void,
        arg: *mut ::std::os::raw::c_void
    );
}
unsafe extern "C" {
    pub fn saucer_webview_on(
        arg1: *mut saucer_handle,
        event: SAUCER_WEB_EVENT,
        callback: *mut ::std::os::raw::c_void
    ) -> u64;
}
unsafe extern "C" {
    pub fn saucer_webview_on_with_arg(
        arg1: *mut saucer_handle,
        event: SAUCER_WEB_EVENT,
        callback: *mut ::std::os::raw::c_void,
        arg: *mut ::std::os::raw::c_void
    ) -> u64;
}
unsafe extern "C" {
    pub fn saucer_register_scheme(name: *const ::std::os::raw::c_char);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct saucer_desktop {
    _unused: [u8; 0]
}
unsafe extern "C" {
    pub fn saucer_desktop_new(app: *mut saucer_application) -> *mut saucer_desktop;
}
unsafe extern "C" {
    pub fn saucer_desktop_free(arg1: *mut saucer_desktop);
}
unsafe extern "C" {
    pub fn saucer_desktop_open(arg1: *mut saucer_desktop, path: *const ::std::os::raw::c_char);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct saucer_picker_options {
    _unused: [u8; 0]
}
unsafe extern "C" {
    pub fn saucer_picker_options_new() -> *mut saucer_picker_options;
}
unsafe extern "C" {
    pub fn saucer_picker_options_free(arg1: *mut saucer_picker_options);
}
unsafe extern "C" {
    pub fn saucer_picker_options_set_initial(arg1: *mut saucer_picker_options, path: *const ::std::os::raw::c_char);
}
unsafe extern "C" {
    pub fn saucer_picker_options_add_filter(arg1: *mut saucer_picker_options, filter: *const ::std::os::raw::c_char);
}
unsafe extern "C" {
    #[doc = " @note The returned array will be populated with strings which are themselves dynamically allocated.\n\n To properly free the returned array you should:\n - Free all strings within the array\n - Free the array itself"]
    pub fn saucer_desktop_pick_file(
        arg1: *mut saucer_desktop,
        options: *mut saucer_picker_options
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn saucer_desktop_pick_folder(
        arg1: *mut saucer_desktop,
        options: *mut saucer_picker_options
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn saucer_desktop_pick_files(
        arg1: *mut saucer_desktop,
        options: *mut saucer_picker_options
    ) -> *mut *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn saucer_desktop_pick_folders(
        arg1: *mut saucer_desktop,
        options: *mut saucer_picker_options
    ) -> *mut *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn saucer_desktop_pick_files_with_size(
        arg1: *mut saucer_desktop,
        options: *mut saucer_picker_options,
        size: *mut usize
    ) -> *mut *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn saucer_desktop_pick_folders_with_size(
        arg1: *mut saucer_desktop,
        options: *mut saucer_picker_options,
        size: *mut usize
    ) -> *mut *mut ::std::os::raw::c_char;
}
pub const SAUCER_LAYOUT_SAUCER_LAYOUT_PORTRAIT: SAUCER_LAYOUT = 0;
pub const SAUCER_LAYOUT_SAUCER_LAYOUT_LANDSCAPE: SAUCER_LAYOUT = 1;
pub type SAUCER_LAYOUT = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct saucer_print_settings {
    _unused: [u8; 0]
}
unsafe extern "C" {
    pub fn saucer_print_settings_new() -> *mut saucer_print_settings;
}
unsafe extern "C" {
    pub fn saucer_print_settings_free(arg1: *mut saucer_print_settings);
}
unsafe extern "C" {
    pub fn saucer_print_settings_set_file(arg1: *mut saucer_print_settings, file: *const ::std::os::raw::c_char);
}
unsafe extern "C" {
    pub fn saucer_print_settings_set_orientation(arg1: *mut saucer_print_settings, orientation: SAUCER_LAYOUT);
}
unsafe extern "C" {
    pub fn saucer_print_settings_set_width(arg1: *mut saucer_print_settings, width: f64);
}
unsafe extern "C" {
    pub fn saucer_print_settings_set_height(arg1: *mut saucer_print_settings, height: f64);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct saucer_pdf {
    _unused: [u8; 0]
}
unsafe extern "C" {
    pub fn saucer_pdf_new(webview: *mut saucer_handle) -> *mut saucer_pdf;
}
unsafe extern "C" {
    pub fn saucer_pdf_free(arg1: *mut saucer_pdf);
}
unsafe extern "C" {
    pub fn saucer_pdf_save(arg1: *mut saucer_pdf, settings: *mut saucer_print_settings);
}
